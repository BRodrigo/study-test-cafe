'use strict';

exports.__esModule = true;

var _lodash = require('lodash');

var _types = require('../types');

var _utils = require('./utils');

const EXTERNAL_LINKS = {
    createNewIssue: 'https://github.com/DevExpress/testcafe/issues/new?template=bug-report.md',
    viewportSizes: 'http://viewportsizes.com'
};

exports.default = {
    [_types.TEST_RUN_ERRORS.actionIntegerOptionError]: err => (0, _utils.markup)(err, `
        The "${err.optionName}" option is expected to be an integer, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionPositiveIntegerOptionError]: err => (0, _utils.markup)(err, `
        The "${err.optionName}" option is expected to be a positive integer, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionBooleanOptionError]: err => (0, _utils.markup)(err, `
        The "${err.optionName}" option is expected to be a boolean value, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionSpeedOptionError]: err => (0, _utils.markup)(err, `
        The "${err.optionName}" option is expected to be a number between 0.01 and 1, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.pageLoadError]: err => (0, _utils.markup)(err, `
        ${err.errMsg}
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorOnPage]: err => (0, _utils.markup)(err, `
        A JavaScript error occurred on ${(0, _utils.formatUrl)(err.pageDestUrl)}.
        At this moment, TestCafe tracks uncaught JavaScript errors on the page. Try to manually perform the test scenario.
        If this error still occurs then it means you site has uncaught JavaScript errors. To disable JavaScript error tracking you can turn the --skip-js-errors option on.
        If the error occurs only with TestCafe then it is a bug. Write a new issue about it at:
        ${(0, _utils.formatUrl)(EXTERNAL_LINKS.createNewIssue)}.

        JavaScript error details:
        ${(0, _utils.replaceLeadingSpacesWithNbsp)((0, _lodash.escape)(err.errStack))}
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorInTestCode]: err => (0, _utils.markup)(err, `
        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.nativeDialogNotHandledError]: err => (0, _utils.markup)(err, `
        A native ${err.dialogType} dialog was invoked on page ${(0, _utils.formatUrl)(err.pageUrl)}, but no handler was set for it. Use the "setNativeDialogHandler" function to introduce a handler function for native dialogs.
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorInNativeDialogHandler]: err => (0, _utils.markup)(err, `
        An error occurred in the native dialog handler called for a native ${err.dialogType} dialog on page ${(0, _utils.formatUrl)(err.pageUrl)}:

        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.setTestSpeedArgumentError]: err => (0, _utils.markup)(err, `
        Speed is expected to be a number between 0.01 and 1, but ${err.actualValue} was passed.
    `),

    [_types.TEST_RUN_ERRORS.setNativeDialogHandlerCodeWrongTypeError]: err => (0, _utils.markup)(err, `
        The native dialog handler is expected to be a function, ClientFunction or null, but it was ${err.actualType}.
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorInClientFunctionCode]: err => (0, _utils.markup)(err, `
        An error occurred in ${err.instantiationCallsiteName} code:

        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorInCustomDOMPropertyCode]: err => (0, _utils.markup)(err, `
        An error occurred when trying to calculate a custom Selector property "${err.property}":

        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.clientFunctionExecutionInterruptionError]: err => (0, _utils.markup)(err, `
        ${err.instantiationCallsiteName} execution was interrupted by page unload. This problem may appear if you trigger page navigation from ${err.instantiationCallsiteName} code.
    `),

    [_types.TEST_RUN_ERRORS.uncaughtNonErrorObjectInTestCode]: err => (0, _utils.markup)(err, `
        Uncaught ${err.objType} "${(0, _lodash.escape)(err.objStr)}" was thrown. Throw Error instead.
    `, { withoutCallsite: true }),

    [_types.TEST_RUN_ERRORS.unhandledPromiseRejection]: err => (0, _utils.markup)(err, `
        Unhandled promise rejection:

        ${(0, _lodash.escape)(err.errMsg)}
    `, { withoutCallsite: true }),

    [_types.TEST_RUN_ERRORS.uncaughtException]: err => (0, _utils.markup)(err, `
        Uncaught exception:

        ${(0, _lodash.escape)(err.errMsg)}
    `, { withoutCallsite: true }),

    [_types.TEST_RUN_ERRORS.actionOptionsTypeError]: err => (0, _utils.markup)(err, `
        Action options is expected to be an object, null or undefined but it was ${err.actualType}.
    `),

    [_types.TEST_RUN_ERRORS.actionStringArgumentError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument is expected to be a non-empty string, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionBooleanArgumentError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument is expected to be a boolean value, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionNullableStringArgumentError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument is expected to be a null or a string, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionStringOrStringArrayArgumentError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument is expected to be a non-empty string or a string array, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionStringArrayElementError]: err => (0, _utils.markup)(err, `
        Elements of the "${err.argumentName}" argument are expected to be non-empty strings, but the element at index ${err.elementIndex} was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionIntegerArgumentError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument is expected to be an integer, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionRoleArgumentError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument is expected to be a Role instance, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionPositiveIntegerArgumentError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument is expected to be a positive integer, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionElementNotFoundError]: (err, viewportWidth) => (0, _utils.markup)(err, `
        The specified selector does not match any element in the DOM tree.

        ${(0, _utils.formatSelectorCallstack)(err.apiFnChain, err.apiFnIndex, viewportWidth)}
    `),

    [_types.TEST_RUN_ERRORS.actionElementIsInvisibleError]: err => (0, _utils.markup)(err, `
        The element that matches the specified selector is not visible.
    `),

    [_types.TEST_RUN_ERRORS.actionSelectorMatchesWrongNodeTypeError]: err => (0, _utils.markup)(err, `
        The specified selector is expected to match a DOM element, but it matches a ${err.nodeDescription} node.
    `),

    [_types.TEST_RUN_ERRORS.actionAdditionalElementNotFoundError]: (err, viewportWidth) => (0, _utils.markup)(err, `
        The specified "${err.argumentName}" does not match any element in the DOM tree.

        ${(0, _utils.formatSelectorCallstack)(err.apiFnChain, err.apiFnIndex, viewportWidth)}
    `),

    [_types.TEST_RUN_ERRORS.actionAdditionalElementIsInvisibleError]: err => (0, _utils.markup)(err, `
        The element that matches the specified "${err.argumentName}" is not visible.
    `),

    [_types.TEST_RUN_ERRORS.actionAdditionalSelectorMatchesWrongNodeTypeError]: err => (0, _utils.markup)(err, `
        The specified "${err.argumentName}" is expected to match a DOM element, but it matches a ${err.nodeDescription} node.
    `),

    [_types.TEST_RUN_ERRORS.actionElementNonEditableError]: err => (0, _utils.markup)(err, `
        The action element is expected to be editable (an input, textarea or element with the contentEditable attribute).
    `),

    [_types.TEST_RUN_ERRORS.actionElementNonContentEditableError]: err => (0, _utils.markup)(err, `
        The element that matches the specified "${err.argumentName}" is expected to have the contentEditable attribute enabled or the entire document should be in design mode.
    `),

    [_types.TEST_RUN_ERRORS.actionRootContainerNotFoundError]: err => (0, _utils.markup)(err, `
        Content between the action elements cannot be selected because the root container for the selection range cannot be found, i.e. these elements do not have a common ancestor with the contentEditable attribute.
    `),

    [_types.TEST_RUN_ERRORS.actionElementIsNotFileInputError]: err => (0, _utils.markup)(err, `
        The specified selector does not match a file input element.
    `),

    [_types.TEST_RUN_ERRORS.actionCannotFindFileToUploadError]: err => (0, _utils.markup)(err, `
        Cannot find the following file(s) to upload:
        ${err.filePaths.map(path => `  ${(0, _lodash.escape)(path)}`).join('\n')}
    `),

    [_types.TEST_RUN_ERRORS.actionElementNotTextAreaError]: err => (0, _utils.markup)(err, `
        The action element is expected to be a &lt;textarea&gt;.
    `),

    [_types.TEST_RUN_ERRORS.actionElementNotIframeError]: err => (0, _utils.markup)(err, `
        The action element is expected to be an &lt;iframe&gt.
    `),

    [_types.TEST_RUN_ERRORS.actionIncorrectKeysError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument contains an incorrect key or key combination.
    `),

    [_types.TEST_RUN_ERRORS.actionUnsupportedDeviceTypeError]: err => (0, _utils.markup)(err, `
        The "${err.argumentName}" argument specifies an unsupported "${err.actualValue}" device. For a list of supported devices, refer to ${(0, _utils.formatUrl)(EXTERNAL_LINKS.viewportSizes)}.
    `),

    [_types.TEST_RUN_ERRORS.actionInvalidScrollTargetError]: err => (0, _utils.markup)(err, `
        Unable to scroll to the specified point because a point with the specified ${err.properties} is not located inside the element's cropping region.
    `),

    [_types.TEST_RUN_ERRORS.actionIframeIsNotLoadedError]: err => (0, _utils.markup)(err, `
        Content of the iframe to which you are switching did not load.
    `),

    [_types.TEST_RUN_ERRORS.currentIframeIsNotLoadedError]: err => (0, _utils.markup)(err, `
        Content of the iframe in which the test is currently operating did not load.
    `),

    [_types.TEST_RUN_ERRORS.currentIframeNotFoundError]: err => (0, _utils.markup)(err, `
        The iframe in which the test is currently operating does not exist anymore.
    `),

    [_types.TEST_RUN_ERRORS.currentIframeIsInvisibleError]: err => (0, _utils.markup)(err, `
        The iframe in which the test is currently operating is not visible anymore.
    `),

    [_types.TEST_RUN_ERRORS.missingAwaitError]: err => (0, _utils.markup)(err, `
        A call to an async function is not awaited. Use the "await" keyword before actions, assertions or chains of them to ensure that they run in the right sequence.
    `),

    [_types.TEST_RUN_ERRORS.externalAssertionLibraryError]: err => (0, _utils.markup)(err, `
        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.domNodeClientFunctionResultError]: err => (0, _utils.markup)(err, `
       ${err.instantiationCallsiteName} cannot return DOM elements. Use Selector functions for this purpose.
    `),

    [_types.TEST_RUN_ERRORS.invalidSelectorResultError]: err => (0, _utils.markup)(err, `
        Function that specifies a selector can only return a DOM node, an array of nodes, NodeList, HTMLCollection, null or undefined. Use ClientFunction to return other values.
    `),

    [_types.TEST_RUN_ERRORS.actionSelectorError]: err => (0, _utils.markup)(err, `
        Action "${err.selectorName}" argument error:

        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.cannotObtainInfoForElementSpecifiedBySelectorError]: (err, viewportWidth) => (0, _utils.markup)(err, `
        Cannot obtain information about the node because the specified selector does not match any node in the DOM tree.

        ${(0, _utils.formatSelectorCallstack)(err.apiFnChain, err.apiFnIndex, viewportWidth)}
    `),

    [_types.TEST_RUN_ERRORS.windowDimensionsOverflowError]: err => (0, _utils.markup)(err, `
        Unable to resize the window because the specified size exceeds the screen size. On macOS, a window cannot be larger than the screen.
    `),

    [_types.TEST_RUN_ERRORS.forbiddenCharactersInScreenshotPathError]: err => (0, _utils.markup)(err, `
        There are forbidden characters in the "${err.screenshotPath}" screenshot path:
        ${(0, _utils.renderForbiddenCharsList)(err.forbiddenCharsList)}
    `),

    [_types.TEST_RUN_ERRORS.invalidElementScreenshotDimensionsError]: err => (0, _utils.markup)(err, `
         Unable to capture an element image because the resulting image ${err.dimensions} ${err.verb} zero or negative.
    `),

    [_types.TEST_RUN_ERRORS.roleSwitchInRoleInitializerError]: err => (0, _utils.markup)(err, `
        Role cannot be switched while another role is being initialized.
    `),

    [_types.TEST_RUN_ERRORS.assertionExecutableArgumentError]: err => (0, _utils.markup)(err, `
        Cannot evaluate the "${err.actualValue}" expression in the "${err.argumentName}" parameter because of the following error:

        ${err.errMsg}
    `),

    [_types.TEST_RUN_ERRORS.assertionWithoutMethodCallError]: err => (0, _utils.markup)(err, `
        An assertion method is not specified.
    `),

    [_types.TEST_RUN_ERRORS.assertionUnawaitedPromiseError]: err => (0, _utils.markup)(err, `
        Attempted to run assertions on a Promise object. Did you forget to await it? If not, pass "{ allowUnawaitedPromise: true }" to the assertion options.
    `)
};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9lcnJvcnMvdGVzdC1ydW4vdGVtcGxhdGVzLmpzIl0sIm5hbWVzIjpbIkVYVEVSTkFMX0xJTktTIiwiY3JlYXRlTmV3SXNzdWUiLCJ2aWV3cG9ydFNpemVzIiwiVEVTVF9SVU5fRVJST1JTIiwiYWN0aW9uSW50ZWdlck9wdGlvbkVycm9yIiwiZXJyIiwib3B0aW9uTmFtZSIsImFjdHVhbFZhbHVlIiwiYWN0aW9uUG9zaXRpdmVJbnRlZ2VyT3B0aW9uRXJyb3IiLCJhY3Rpb25Cb29sZWFuT3B0aW9uRXJyb3IiLCJhY3Rpb25TcGVlZE9wdGlvbkVycm9yIiwicGFnZUxvYWRFcnJvciIsImVyck1zZyIsInVuY2F1Z2h0RXJyb3JPblBhZ2UiLCJwYWdlRGVzdFVybCIsImVyclN0YWNrIiwidW5jYXVnaHRFcnJvckluVGVzdENvZGUiLCJuYXRpdmVEaWFsb2dOb3RIYW5kbGVkRXJyb3IiLCJkaWFsb2dUeXBlIiwicGFnZVVybCIsInVuY2F1Z2h0RXJyb3JJbk5hdGl2ZURpYWxvZ0hhbmRsZXIiLCJzZXRUZXN0U3BlZWRBcmd1bWVudEVycm9yIiwic2V0TmF0aXZlRGlhbG9nSGFuZGxlckNvZGVXcm9uZ1R5cGVFcnJvciIsImFjdHVhbFR5cGUiLCJ1bmNhdWdodEVycm9ySW5DbGllbnRGdW5jdGlvbkNvZGUiLCJpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lIiwidW5jYXVnaHRFcnJvckluQ3VzdG9tRE9NUHJvcGVydHlDb2RlIiwicHJvcGVydHkiLCJjbGllbnRGdW5jdGlvbkV4ZWN1dGlvbkludGVycnVwdGlvbkVycm9yIiwidW5jYXVnaHROb25FcnJvck9iamVjdEluVGVzdENvZGUiLCJvYmpUeXBlIiwib2JqU3RyIiwid2l0aG91dENhbGxzaXRlIiwidW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbiIsInVuY2F1Z2h0RXhjZXB0aW9uIiwiYWN0aW9uT3B0aW9uc1R5cGVFcnJvciIsImFjdGlvblN0cmluZ0FyZ3VtZW50RXJyb3IiLCJhcmd1bWVudE5hbWUiLCJhY3Rpb25Cb29sZWFuQXJndW1lbnRFcnJvciIsImFjdGlvbk51bGxhYmxlU3RyaW5nQXJndW1lbnRFcnJvciIsImFjdGlvblN0cmluZ09yU3RyaW5nQXJyYXlBcmd1bWVudEVycm9yIiwiYWN0aW9uU3RyaW5nQXJyYXlFbGVtZW50RXJyb3IiLCJlbGVtZW50SW5kZXgiLCJhY3Rpb25JbnRlZ2VyQXJndW1lbnRFcnJvciIsImFjdGlvblJvbGVBcmd1bWVudEVycm9yIiwiYWN0aW9uUG9zaXRpdmVJbnRlZ2VyQXJndW1lbnRFcnJvciIsImFjdGlvbkVsZW1lbnROb3RGb3VuZEVycm9yIiwidmlld3BvcnRXaWR0aCIsImFwaUZuQ2hhaW4iLCJhcGlGbkluZGV4IiwiYWN0aW9uRWxlbWVudElzSW52aXNpYmxlRXJyb3IiLCJhY3Rpb25TZWxlY3Rvck1hdGNoZXNXcm9uZ05vZGVUeXBlRXJyb3IiLCJub2RlRGVzY3JpcHRpb24iLCJhY3Rpb25BZGRpdGlvbmFsRWxlbWVudE5vdEZvdW5kRXJyb3IiLCJhY3Rpb25BZGRpdGlvbmFsRWxlbWVudElzSW52aXNpYmxlRXJyb3IiLCJhY3Rpb25BZGRpdGlvbmFsU2VsZWN0b3JNYXRjaGVzV3JvbmdOb2RlVHlwZUVycm9yIiwiYWN0aW9uRWxlbWVudE5vbkVkaXRhYmxlRXJyb3IiLCJhY3Rpb25FbGVtZW50Tm9uQ29udGVudEVkaXRhYmxlRXJyb3IiLCJhY3Rpb25Sb290Q29udGFpbmVyTm90Rm91bmRFcnJvciIsImFjdGlvbkVsZW1lbnRJc05vdEZpbGVJbnB1dEVycm9yIiwiYWN0aW9uQ2Fubm90RmluZEZpbGVUb1VwbG9hZEVycm9yIiwiZmlsZVBhdGhzIiwibWFwIiwicGF0aCIsImpvaW4iLCJhY3Rpb25FbGVtZW50Tm90VGV4dEFyZWFFcnJvciIsImFjdGlvbkVsZW1lbnROb3RJZnJhbWVFcnJvciIsImFjdGlvbkluY29ycmVjdEtleXNFcnJvciIsImFjdGlvblVuc3VwcG9ydGVkRGV2aWNlVHlwZUVycm9yIiwiYWN0aW9uSW52YWxpZFNjcm9sbFRhcmdldEVycm9yIiwicHJvcGVydGllcyIsImFjdGlvbklmcmFtZUlzTm90TG9hZGVkRXJyb3IiLCJjdXJyZW50SWZyYW1lSXNOb3RMb2FkZWRFcnJvciIsImN1cnJlbnRJZnJhbWVOb3RGb3VuZEVycm9yIiwiY3VycmVudElmcmFtZUlzSW52aXNpYmxlRXJyb3IiLCJtaXNzaW5nQXdhaXRFcnJvciIsImV4dGVybmFsQXNzZXJ0aW9uTGlicmFyeUVycm9yIiwiZG9tTm9kZUNsaWVudEZ1bmN0aW9uUmVzdWx0RXJyb3IiLCJpbnZhbGlkU2VsZWN0b3JSZXN1bHRFcnJvciIsImFjdGlvblNlbGVjdG9yRXJyb3IiLCJzZWxlY3Rvck5hbWUiLCJjYW5ub3RPYnRhaW5JbmZvRm9yRWxlbWVudFNwZWNpZmllZEJ5U2VsZWN0b3JFcnJvciIsIndpbmRvd0RpbWVuc2lvbnNPdmVyZmxvd0Vycm9yIiwiZm9yYmlkZGVuQ2hhcmFjdGVyc0luU2NyZWVuc2hvdFBhdGhFcnJvciIsInNjcmVlbnNob3RQYXRoIiwiZm9yYmlkZGVuQ2hhcnNMaXN0IiwiaW52YWxpZEVsZW1lbnRTY3JlZW5zaG90RGltZW5zaW9uc0Vycm9yIiwiZGltZW5zaW9ucyIsInZlcmIiLCJyb2xlU3dpdGNoSW5Sb2xlSW5pdGlhbGl6ZXJFcnJvciIsImFzc2VydGlvbkV4ZWN1dGFibGVBcmd1bWVudEVycm9yIiwiYXNzZXJ0aW9uV2l0aG91dE1ldGhvZENhbGxFcnJvciIsImFzc2VydGlvblVuYXdhaXRlZFByb21pc2VFcnJvciJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUNBOztBQUNBOztBQVFBLE1BQU1BLGlCQUFpQjtBQUNuQkMsb0JBQWdCLDBFQURHO0FBRW5CQyxtQkFBZ0I7QUFGRyxDQUF2Qjs7a0JBS2U7QUFDWCxLQUFDQyx1QkFBZ0JDLHdCQUFqQixHQUE0Q0MsT0FBTyxtQkFBT0EsR0FBUCxFQUFhO2VBQ3JEQSxJQUFJQyxVQUFXLHFEQUFvREQsSUFBSUUsV0FBWTtLQUQzQyxDQUR4Qzs7QUFLWCxLQUFDSix1QkFBZ0JL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QXdCLG1CQUFPMUMsR0FBUCxFQUFhOzs7VUFHcEcsb0NBQXdCQSxJQUFJMkMsVUFBNUIsRUFBd0MzQyxJQUFJNEMsVUFBNUMsRUFBd0RGLGFBQXhELENBQXdFO0tBSGUsQ0FyT25GOztBQTJPWCxLQUFDNUMsdUJBQWdCK0UsNkJBQWpCLEdBQWlEN0UsT0FBTyxtQkFBT0EsR0FBUCxFQUFhOztLQUFiLENBM083Qzs7QUErT1gsS0FBQ0YsdUJBQWdCZ0Ysd0NBQWpCLEdBQTREOUUsT0FBTyxtQkFBT0EsR0FBUCxFQUFhO2lEQUNuQ0EsSUFBSStFLGNBQWU7VUFDMUQscUNBQXlCL0UsSUFBSWdGLGtCQUE3QixDQUFpRDtLQUZZLENBL094RDs7QUFvUFgsS0FBQ2xGLHVCQUFnQm1GLHVDQUFqQixHQUEyRGpGLE9BQU8sbUJBQU9BLEdBQVAsRUFBYTswRUFDVEEsSUFBSWtGLFVBQVcsSUFBR2xGLElBQUltRixJQUFLO0tBRC9CLENBcFB2RDs7QUF3UFgsS0FBQ3JGLHVCQUFnQnNGLGdDQUFqQixHQUFvRHBGLE9BQU8sbUJBQU9BLEdBQVAsRUFBYTs7S0FBYixDQXhQaEQ7O0FBNFBYLEtBQUNGLHVCQUFnQnVGLGdDQUFqQixHQUFvRHJGLE9BQU8sbUJBQU9BLEdBQVAsRUFBYTsrQkFDN0NBLElBQUlFLFdBQVksd0JBQXVCRixJQUFJZ0MsWUFBYTs7VUFFN0VoQyxJQUFJTyxNQUFPO0tBSDBDLENBNVBoRDs7QUFrUVgsS0FBQ1QsdUJBQWdCd0YsK0JBQWpCLEdBQW1EdEYsT0FBTyxtQkFBT0EsR0FBUCxFQUFhOztLQUFiLENBbFEvQzs7QUFzUVgsS0FBQ0YsdUJBQWdCeUYsOEJBQWpCLEdBQWtEdkYsT0FBTyxtQkFBT0EsR0FBUCxFQUFhOztLQUFiO0FBdFE5QyxDIiwiZmlsZSI6ImVycm9ycy90ZXN0LXJ1bi90ZW1wbGF0ZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlc2NhcGUgYXMgZXNjYXBlSHRtbCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBURVNUX1JVTl9FUlJPUlMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICAgIHJlbmRlckZvcmJpZGRlbkNoYXJzTGlzdCxcbiAgICBtYXJrdXAsXG4gICAgZm9ybWF0U2VsZWN0b3JDYWxsc3RhY2ssXG4gICAgZm9ybWF0VXJsLFxuICAgIHJlcGxhY2VMZWFkaW5nU3BhY2VzV2l0aE5ic3Bcbn0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IEVYVEVSTkFMX0xJTktTID0ge1xuICAgIGNyZWF0ZU5ld0lzc3VlOiAnaHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmUvaXNzdWVzL25ldz90ZW1wbGF0ZT1idWctcmVwb3J0Lm1kJyxcbiAgICB2aWV3cG9ydFNpemVzOiAgJ2h0dHA6Ly92aWV3cG9ydHNpemVzLmNvbSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkludGVnZXJPcHRpb25FcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLm9wdGlvbk5hbWV9XCIgb3B0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25Qb3NpdGl2ZUludGVnZXJPcHRpb25FcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLm9wdGlvbk5hbWV9XCIgb3B0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGl0IHdhcyAke2Vyci5hY3R1YWxWYWx1ZX0uXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkJvb2xlYW5PcHRpb25FcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLm9wdGlvbk5hbWV9XCIgb3B0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIGEgYm9vbGVhbiB2YWx1ZSwgYnV0IGl0IHdhcyAke2Vyci5hY3R1YWxWYWx1ZX0uXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvblNwZWVkT3B0aW9uRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5vcHRpb25OYW1lfVwiIG9wdGlvbiBpcyBleHBlY3RlZCB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAuMDEgYW5kIDEsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5wYWdlTG9hZEVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgJHtlcnIuZXJyTXNnfVxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy51bmNhdWdodEVycm9yT25QYWdlXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQSBKYXZhU2NyaXB0IGVycm9yIG9jY3VycmVkIG9uICR7Zm9ybWF0VXJsKGVyci5wYWdlRGVzdFVybCl9LlxuICAgICAgICBBdCB0aGlzIG1vbWVudCwgVGVzdENhZmUgdHJhY2tzIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3JzIG9uIHRoZSBwYWdlLiBUcnkgdG8gbWFudWFsbHkgcGVyZm9ybSB0aGUgdGVzdCBzY2VuYXJpby5cbiAgICAgICAgSWYgdGhpcyBlcnJvciBzdGlsbCBvY2N1cnMgdGhlbiBpdCBtZWFucyB5b3Ugc2l0ZSBoYXMgdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvcnMuIFRvIGRpc2FibGUgSmF2YVNjcmlwdCBlcnJvciB0cmFja2luZyB5b3UgY2FuIHR1cm4gdGhlIC0tc2tpcC1qcy1lcnJvcnMgb3B0aW9uIG9uLlxuICAgICAgICBJZiB0aGUgZXJyb3Igb2NjdXJzIG9ubHkgd2l0aCBUZXN0Q2FmZSB0aGVuIGl0IGlzIGEgYnVnLiBXcml0ZSBhIG5ldyBpc3N1ZSBhYm91dCBpdCBhdDpcbiAgICAgICAgJHtmb3JtYXRVcmwoRVhURVJOQUxfTElOS1MuY3JlYXRlTmV3SXNzdWUpfS5cblxuICAgICAgICBKYXZhU2NyaXB0IGVycm9yIGRldGFpbHM6XG4gICAgICAgICR7cmVwbGFjZUxlYWRpbmdTcGFjZXNXaXRoTmJzcChlc2NhcGVIdG1sKGVyci5lcnJTdGFjaykpfVxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy51bmNhdWdodEVycm9ySW5UZXN0Q29kZV06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgICR7ZXNjYXBlSHRtbChlcnIuZXJyTXNnKX1cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMubmF0aXZlRGlhbG9nTm90SGFuZGxlZEVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQSBuYXRpdmUgJHtlcnIuZGlhbG9nVHlwZX0gZGlhbG9nIHdhcyBpbnZva2VkIG9uIHBhZ2UgJHtmb3JtYXRVcmwoZXJyLnBhZ2VVcmwpfSwgYnV0IG5vIGhhbmRsZXIgd2FzIHNldCBmb3IgaXQuIFVzZSB0aGUgXCJzZXROYXRpdmVEaWFsb2dIYW5kbGVyXCIgZnVuY3Rpb24gdG8gaW50cm9kdWNlIGEgaGFuZGxlciBmdW5jdGlvbiBmb3IgbmF0aXZlIGRpYWxvZ3MuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnVuY2F1Z2h0RXJyb3JJbk5hdGl2ZURpYWxvZ0hhbmRsZXJdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgbmF0aXZlIGRpYWxvZyBoYW5kbGVyIGNhbGxlZCBmb3IgYSBuYXRpdmUgJHtlcnIuZGlhbG9nVHlwZX0gZGlhbG9nIG9uIHBhZ2UgJHtmb3JtYXRVcmwoZXJyLnBhZ2VVcmwpfTpcblxuICAgICAgICAke2VzY2FwZUh0bWwoZXJyLmVyck1zZyl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnNldFRlc3RTcGVlZEFyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBTcGVlZCBpcyBleHBlY3RlZCB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAuMDEgYW5kIDEsIGJ1dCAke2Vyci5hY3R1YWxWYWx1ZX0gd2FzIHBhc3NlZC5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuc2V0TmF0aXZlRGlhbG9nSGFuZGxlckNvZGVXcm9uZ1R5cGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBuYXRpdmUgZGlhbG9nIGhhbmRsZXIgaXMgZXhwZWN0ZWQgdG8gYmUgYSBmdW5jdGlvbiwgQ2xpZW50RnVuY3Rpb24gb3IgbnVsbCwgYnV0IGl0IHdhcyAke2Vyci5hY3R1YWxUeXBlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMudW5jYXVnaHRFcnJvckluQ2xpZW50RnVuY3Rpb25Db2RlXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQW4gZXJyb3Igb2NjdXJyZWQgaW4gJHtlcnIuaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZTpcblxuICAgICAgICAke2VzY2FwZUh0bWwoZXJyLmVyck1zZyl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnVuY2F1Z2h0RXJyb3JJbkN1c3RvbURPTVByb3BlcnR5Q29kZV06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gdHJ5aW5nIHRvIGNhbGN1bGF0ZSBhIGN1c3RvbSBTZWxlY3RvciBwcm9wZXJ0eSBcIiR7ZXJyLnByb3BlcnR5fVwiOlxuXG4gICAgICAgICR7ZXNjYXBlSHRtbChlcnIuZXJyTXNnKX1cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuY2xpZW50RnVuY3Rpb25FeGVjdXRpb25JbnRlcnJ1cHRpb25FcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgICR7ZXJyLmluc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGV4ZWN1dGlvbiB3YXMgaW50ZXJydXB0ZWQgYnkgcGFnZSB1bmxvYWQuIFRoaXMgcHJvYmxlbSBtYXkgYXBwZWFyIGlmIHlvdSB0cmlnZ2VyIHBhZ2UgbmF2aWdhdGlvbiBmcm9tICR7ZXJyLmluc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNvZGUuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnVuY2F1Z2h0Tm9uRXJyb3JPYmplY3RJblRlc3RDb2RlXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVW5jYXVnaHQgJHtlcnIub2JqVHlwZX0gXCIke2VzY2FwZUh0bWwoZXJyLm9ialN0cil9XCIgd2FzIHRocm93bi4gVGhyb3cgRXJyb3IgaW5zdGVhZC5cbiAgICBgLCB7IHdpdGhvdXRDYWxsc2l0ZTogdHJ1ZSB9KSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMudW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcblxuICAgICAgICAke2VzY2FwZUh0bWwoZXJyLmVyck1zZyl9XG4gICAgYCwgeyB3aXRob3V0Q2FsbHNpdGU6IHRydWUgfSksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnVuY2F1Z2h0RXhjZXB0aW9uXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVW5jYXVnaHQgZXhjZXB0aW9uOlxuXG4gICAgICAgICR7ZXNjYXBlSHRtbChlcnIuZXJyTXNnKX1cbiAgICBgLCB7IHdpdGhvdXRDYWxsc2l0ZTogdHJ1ZSB9KSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uT3B0aW9uc1R5cGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEFjdGlvbiBvcHRpb25zIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCwgbnVsbCBvciB1bmRlZmluZWQgYnV0IGl0IHdhcyAke2Vyci5hY3R1YWxUeXBlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uU3RyaW5nQXJndW1lbnRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25Cb29sZWFuQXJndW1lbnRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIGJvb2xlYW4gdmFsdWUsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25OdWxsYWJsZVN0cmluZ0FyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBudWxsIG9yIGEgc3RyaW5nLCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uU3RyaW5nT3JTdHJpbmdBcnJheUFyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgc3RyaW5nIGFycmF5LCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uU3RyaW5nQXJyYXlFbGVtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBFbGVtZW50cyBvZiB0aGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgYXJlIGV4cGVjdGVkIHRvIGJlIG5vbi1lbXB0eSBzdHJpbmdzLCBidXQgdGhlIGVsZW1lbnQgYXQgaW5kZXggJHtlcnIuZWxlbWVudEluZGV4fSB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25JbnRlZ2VyQXJndW1lbnRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uUm9sZUFyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBSb2xlIGluc3RhbmNlLCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uUG9zaXRpdmVJbnRlZ2VyQXJndW1lbnRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25FbGVtZW50Tm90Rm91bmRFcnJvcl06IChlcnIsIHZpZXdwb3J0V2lkdGgpID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIHNwZWNpZmllZCBzZWxlY3RvciBkb2VzIG5vdCBtYXRjaCBhbnkgZWxlbWVudCBpbiB0aGUgRE9NIHRyZWUuXG5cbiAgICAgICAgJHsgZm9ybWF0U2VsZWN0b3JDYWxsc3RhY2soZXJyLmFwaUZuQ2hhaW4sIGVyci5hcGlGbkluZGV4LCB2aWV3cG9ydFdpZHRoKSB9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkVsZW1lbnRJc0ludmlzaWJsZUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgaXMgbm90IHZpc2libGUuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvblNlbGVjdG9yTWF0Y2hlc1dyb25nTm9kZVR5cGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgaXMgZXhwZWN0ZWQgdG8gbWF0Y2ggYSBET00gZWxlbWVudCwgYnV0IGl0IG1hdGNoZXMgYSAke2Vyci5ub2RlRGVzY3JpcHRpb259IG5vZGUuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkFkZGl0aW9uYWxFbGVtZW50Tm90Rm91bmRFcnJvcl06IChlcnIsIHZpZXdwb3J0V2lkdGgpID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIHNwZWNpZmllZCBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgZWxlbWVudCBpbiB0aGUgRE9NIHRyZWUuXG5cbiAgICAgICAgJHsgZm9ybWF0U2VsZWN0b3JDYWxsc3RhY2soZXJyLmFwaUZuQ2hhaW4sIGVyci5hcGlGbkluZGV4LCB2aWV3cG9ydFdpZHRoKSB9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkFkZGl0aW9uYWxFbGVtZW50SXNJbnZpc2libGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIFwiJHtlcnIuYXJndW1lbnROYW1lfVwiIGlzIG5vdCB2aXNpYmxlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25BZGRpdGlvbmFsU2VsZWN0b3JNYXRjaGVzV3JvbmdOb2RlVHlwZUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIHNwZWNpZmllZCBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBpcyBleHBlY3RlZCB0byBtYXRjaCBhIERPTSBlbGVtZW50LCBidXQgaXQgbWF0Y2hlcyBhICR7ZXJyLm5vZGVEZXNjcmlwdGlvbn0gbm9kZS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uRWxlbWVudE5vbkVkaXRhYmxlRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgYWN0aW9uIGVsZW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgZWRpdGFibGUgKGFuIGlucHV0LCB0ZXh0YXJlYSBvciBlbGVtZW50IHdpdGggdGhlIGNvbnRlbnRFZGl0YWJsZSBhdHRyaWJ1dGUpLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25FbGVtZW50Tm9uQ29udGVudEVkaXRhYmxlRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBjb250ZW50RWRpdGFibGUgYXR0cmlidXRlIGVuYWJsZWQgb3IgdGhlIGVudGlyZSBkb2N1bWVudCBzaG91bGQgYmUgaW4gZGVzaWduIG1vZGUuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvblJvb3RDb250YWluZXJOb3RGb3VuZEVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQ29udGVudCBiZXR3ZWVuIHRoZSBhY3Rpb24gZWxlbWVudHMgY2Fubm90IGJlIHNlbGVjdGVkIGJlY2F1c2UgdGhlIHJvb3QgY29udGFpbmVyIGZvciB0aGUgc2VsZWN0aW9uIHJhbmdlIGNhbm5vdCBiZSBmb3VuZCwgaS5lLiB0aGVzZSBlbGVtZW50cyBkbyBub3QgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvciB3aXRoIHRoZSBjb250ZW50RWRpdGFibGUgYXR0cmlidXRlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25FbGVtZW50SXNOb3RGaWxlSW5wdXRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgZG9lcyBub3QgbWF0Y2ggYSBmaWxlIGlucHV0IGVsZW1lbnQuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkNhbm5vdEZpbmRGaWxlVG9VcGxvYWRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIENhbm5vdCBmaW5kIHRoZSBmb2xsb3dpbmcgZmlsZShzKSB0byB1cGxvYWQ6XG4gICAgICAgICR7ZXJyLmZpbGVQYXRocy5tYXAocGF0aCA9PiBgICAke2VzY2FwZUh0bWwocGF0aCl9YCkuam9pbignXFxuJyl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkVsZW1lbnROb3RUZXh0QXJlYUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIGFjdGlvbiBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgJmx0O3RleHRhcmVhJmd0Oy5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uRWxlbWVudE5vdElmcmFtZUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIGFjdGlvbiBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGFuICZsdDtpZnJhbWUmZ3QuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkluY29ycmVjdEtleXNFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBjb250YWlucyBhbiBpbmNvcnJlY3Qga2V5IG9yIGtleSBjb21iaW5hdGlvbi5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uVW5zdXBwb3J0ZWREZXZpY2VUeXBlRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgc3BlY2lmaWVzIGFuIHVuc3VwcG9ydGVkIFwiJHtlcnIuYWN0dWFsVmFsdWV9XCIgZGV2aWNlLiBGb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBkZXZpY2VzLCByZWZlciB0byAke2Zvcm1hdFVybChFWFRFUk5BTF9MSU5LUy52aWV3cG9ydFNpemVzKX0uXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkludmFsaWRTY3JvbGxUYXJnZXRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFVuYWJsZSB0byBzY3JvbGwgdG8gdGhlIHNwZWNpZmllZCBwb2ludCBiZWNhdXNlIGEgcG9pbnQgd2l0aCB0aGUgc3BlY2lmaWVkICR7ZXJyLnByb3BlcnRpZXN9IGlzIG5vdCBsb2NhdGVkIGluc2lkZSB0aGUgZWxlbWVudCdzIGNyb3BwaW5nIHJlZ2lvbi5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uSWZyYW1lSXNOb3RMb2FkZWRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIENvbnRlbnQgb2YgdGhlIGlmcmFtZSB0byB3aGljaCB5b3UgYXJlIHN3aXRjaGluZyBkaWQgbm90IGxvYWQuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmN1cnJlbnRJZnJhbWVJc05vdExvYWRlZEVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQ29udGVudCBvZiB0aGUgaWZyYW1lIGluIHdoaWNoIHRoZSB0ZXN0IGlzIGN1cnJlbnRseSBvcGVyYXRpbmcgZGlkIG5vdCBsb2FkLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5jdXJyZW50SWZyYW1lTm90Rm91bmRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBpZnJhbWUgaW4gd2hpY2ggdGhlIHRlc3QgaXMgY3VycmVudGx5IG9wZXJhdGluZyBkb2VzIG5vdCBleGlzdCBhbnltb3JlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5jdXJyZW50SWZyYW1lSXNJbnZpc2libGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBpZnJhbWUgaW4gd2hpY2ggdGhlIHRlc3QgaXMgY3VycmVudGx5IG9wZXJhdGluZyBpcyBub3QgdmlzaWJsZSBhbnltb3JlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5taXNzaW5nQXdhaXRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEEgY2FsbCB0byBhbiBhc3luYyBmdW5jdGlvbiBpcyBub3QgYXdhaXRlZC4gVXNlIHRoZSBcImF3YWl0XCIga2V5d29yZCBiZWZvcmUgYWN0aW9ucywgYXNzZXJ0aW9ucyBvciBjaGFpbnMgb2YgdGhlbSB0byBlbnN1cmUgdGhhdCB0aGV5IHJ1biBpbiB0aGUgcmlnaHQgc2VxdWVuY2UuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmV4dGVybmFsQXNzZXJ0aW9uTGlicmFyeUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgJHtlc2NhcGVIdG1sKGVyci5lcnJNc2cpfVxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5kb21Ob2RlQ2xpZW50RnVuY3Rpb25SZXN1bHRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgJHtlcnIuaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY2Fubm90IHJldHVybiBET00gZWxlbWVudHMuIFVzZSBTZWxlY3RvciBmdW5jdGlvbnMgZm9yIHRoaXMgcHVycG9zZS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuaW52YWxpZFNlbGVjdG9yUmVzdWx0RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBGdW5jdGlvbiB0aGF0IHNwZWNpZmllcyBhIHNlbGVjdG9yIGNhbiBvbmx5IHJldHVybiBhIERPTSBub2RlLCBhbiBhcnJheSBvZiBub2RlcywgTm9kZUxpc3QsIEhUTUxDb2xsZWN0aW9uLCBudWxsIG9yIHVuZGVmaW5lZC4gVXNlIENsaWVudEZ1bmN0aW9uIHRvIHJldHVybiBvdGhlciB2YWx1ZXMuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvblNlbGVjdG9yRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBBY3Rpb24gXCIke2Vyci5zZWxlY3Rvck5hbWV9XCIgYXJndW1lbnQgZXJyb3I6XG5cbiAgICAgICAgJHtlc2NhcGVIdG1sKGVyci5lcnJNc2cpfVxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5jYW5ub3RPYnRhaW5JbmZvRm9yRWxlbWVudFNwZWNpZmllZEJ5U2VsZWN0b3JFcnJvcl06IChlcnIsIHZpZXdwb3J0V2lkdGgpID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQ2Fubm90IG9idGFpbiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbm9kZSBiZWNhdXNlIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgZG9lcyBub3QgbWF0Y2ggYW55IG5vZGUgaW4gdGhlIERPTSB0cmVlLlxuXG4gICAgICAgICR7IGZvcm1hdFNlbGVjdG9yQ2FsbHN0YWNrKGVyci5hcGlGbkNoYWluLCBlcnIuYXBpRm5JbmRleCwgdmlld3BvcnRXaWR0aCkgfVxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy53aW5kb3dEaW1lbnNpb25zT3ZlcmZsb3dFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFVuYWJsZSB0byByZXNpemUgdGhlIHdpbmRvdyBiZWNhdXNlIHRoZSBzcGVjaWZpZWQgc2l6ZSBleGNlZWRzIHRoZSBzY3JlZW4gc2l6ZS4gT24gbWFjT1MsIGEgd2luZG93IGNhbm5vdCBiZSBsYXJnZXIgdGhhbiB0aGUgc2NyZWVuLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5mb3JiaWRkZW5DaGFyYWN0ZXJzSW5TY3JlZW5zaG90UGF0aEVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlcmUgYXJlIGZvcmJpZGRlbiBjaGFyYWN0ZXJzIGluIHRoZSBcIiR7ZXJyLnNjcmVlbnNob3RQYXRofVwiIHNjcmVlbnNob3QgcGF0aDpcbiAgICAgICAgJHtyZW5kZXJGb3JiaWRkZW5DaGFyc0xpc3QoZXJyLmZvcmJpZGRlbkNoYXJzTGlzdCl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmludmFsaWRFbGVtZW50U2NyZWVuc2hvdERpbWVuc2lvbnNFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgICBVbmFibGUgdG8gY2FwdHVyZSBhbiBlbGVtZW50IGltYWdlIGJlY2F1c2UgdGhlIHJlc3VsdGluZyBpbWFnZSAke2Vyci5kaW1lbnNpb25zfSAke2Vyci52ZXJifSB6ZXJvIG9yIG5lZ2F0aXZlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5yb2xlU3dpdGNoSW5Sb2xlSW5pdGlhbGl6ZXJFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFJvbGUgY2Fubm90IGJlIHN3aXRjaGVkIHdoaWxlIGFub3RoZXIgcm9sZSBpcyBiZWluZyBpbml0aWFsaXplZC5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYXNzZXJ0aW9uRXhlY3V0YWJsZUFyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBDYW5ub3QgZXZhbHVhdGUgdGhlIFwiJHtlcnIuYWN0dWFsVmFsdWV9XCIgZXhwcmVzc2lvbiBpbiB0aGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgcGFyYW1ldGVyIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcjpcblxuICAgICAgICAke2Vyci5lcnJNc2d9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFzc2VydGlvbldpdGhvdXRNZXRob2RDYWxsRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBBbiBhc3NlcnRpb24gbWV0aG9kIGlzIG5vdCBzcGVjaWZpZWQuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFzc2VydGlvblVuYXdhaXRlZFByb21pc2VFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEF0dGVtcHRlZCB0byBydW4gYXNzZXJ0aW9ucyBvbiBhIFByb21pc2Ugb2JqZWN0LiBEaWQgeW91IGZvcmdldCB0byBhd2FpdCBpdD8gSWYgbm90LCBwYXNzIFwieyBhbGxvd1VuYXdhaXRlZFByb21pc2U6IHRydWUgfVwiIHRvIHRoZSBhc3NlcnRpb24gb3B0aW9ucy5cbiAgICBgKVxufTtcbiJdfQ==
